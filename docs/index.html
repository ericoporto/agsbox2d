<!DOCTYPE html>
<html>
	<head>
        <title>AgsBox2D Hacky Editor</title>	
				<meta name="theme-color" content="#000000">
        <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />	
        <meta charset="UTF-8"/>
        <!-- <link rel="stylesheet" href="milligram.css"> -->
  </head>
<body>

<p>Drop an image on the canvas to use as background.
  <button id="btn_newrect">
    +rect
  </button>
    <button id="btn_reset">
    reset
    </button>
    <button id="btn_generatecode">
    generate code
    </button>
    <img style="display: none;" id="hidden_img"/>
</p>

<div id="container_div" style="position: relative;">
 <canvas id="layer1" width=500 height=500 
   style="position: relative; image-rendering: optimize-contrast; image-rendering: pixelated; image-rendering: crisp-edges; image-rendering: -moz-crisp-edges; left: 0; top: 0; z-index: 0; border: 5px solid blue;"></canvas>
 <canvas id="layer2" width=500 height=500 
   style="position: absolute; left: 0; top: 0; z-index: 1; border: 5px solid blue;"></canvas>
</div>

<div id="code_div" style="position: relative;">
<p><textarea class="code" id="text_code" rows="8" cols="50">

</textarea>
</p>
</div>

<script>
function setpixelated(context){
    context['imageSmoothingEnabled'] = false;       /* standard */
    context['mozImageSmoothingEnabled'] = false;    /* Firefox */
    context['oImageSmoothingEnabled'] = false;      /* Opera */
    context['webkitImageSmoothingEnabled'] = false; /* Safari */
    context['msImageSmoothingEnabled'] = false;     /* IE */
}

  var canvas = document.getElementById('layer2'),
    bgcanvas = document.getElementById('layer1'),
    code_text = document.getElementById('text_code'),
    cdiv = document.getElementById('container_div'),
    ctx = canvas.getContext('2d'),
    bgctx = bgcanvas.getContext('2d'),
    drag = false,
    mouseX,
    mouseY,
    rects = [],
    zoom = 2,
    closeEnough = 7;


  function newRect() {
    rects.unshift({
      startX: 100,
      startY: 200,
      w: 300,
      h: 200,
      dragTL: false,
      dragBL: false,
      dragTR: false,
      dragBR: false,
      dragMove: false,
      initMouseX: -1,
      initMouseY: -1,
      originalStartX: 100,
      originalStartY: 200,
    });
    draw();
  }

  function init() {
    setpixelated(ctx)
    setpixelated(bgctx)
    canvas.addEventListener('mousedown', mouseDown, false);
    canvas.addEventListener('mouseup', mouseUp, false);
    canvas.addEventListener('mousemove', mouseMove, false);
    canvas.addEventListener('touchstart', ontouchstart, false);
    canvas.addEventListener('touchup', ontouchend, false);
    canvas.addEventListener('touchmove', ontouchmove, false);
    document.getElementById("btn_newrect").addEventListener("click", newRect);
    document.getElementById("btn_reset").addEventListener("click", resetCanvas);
    document.getElementById("btn_generatecode").addEventListener("click", generateCode);
    canvas.ondragover = canvas.ondrag = canvas.ondragout = function(e) {
        e.preventDefault();
    }
    canvas.ondrop = function(e) {
        e.preventDefault();

        function doImage(src, title, type) {
            var img = document.getElementById('hidden_img');
            img.src = src;
            img.title = '[' + type + '] ' + title;
            img.onload = function(e){
              setpixelated(bgctx)
              var img = document.getElementById('hidden_img')
              canvas.width = img.width*zoom;
              canvas.height = img.height*zoom;

              bgcanvas.width = img.width*zoom;
              bgcanvas.height = img.height*zoom;

              if(img.src.length > 0){
                bgctx.drawImage(img,0,0,img.width,img.height,0,0,img.width*zoom,img.height*zoom)
              }
              draw();
              img.onload = function(){}
              setpixelated(bgctx)
            }

        }

        var files = e.dataTransfer.files;
        console.log(files);
        for ( var i=0, L=files.length; i<L; i++ ) {
            var file = files[i];

            var filereader = new FileReader();
            filereader.onload = function(e) {
                doImage(this.result, file.name, 'FileReader');
            };
            filereader.readAsDataURL(file);

            doImage(URL.createObjectURL(file), file.name, 'createObjectURL');
        }

        return false;
    }

  }

  function generateCode() {
    s = "Body* setWalls(World* wrld) { \n"
    s = s + "  Body* _w = new Body[" + (rects.length+1) +"]; \n"

    for (var i=0; i<rects.length; i++){
      var rect = rects[i];
      var center_x = rect.startX + rect.w/2;
      var center_y = rect.startY + rect.h/2;
      s = s + "  _w["+i+"] = AgsBox2D.CreateBody(wrld, " + center_x.toFixed(1) + ", " + center_y.toFixed(1) + ", eBodyStatic); \n"
      s = s + "  AgsBox2D.CreateFixture(_w["+i+"], AgsBox2D.CreateRectangleShape("+rect.w.toFixed(1)+", "+rect.h.toFixed(1)+")); \n"
    }
    s = s + "  _w["+i+"] = null; \n"
    s = s + "  return _w; \n"
    s = s + "} \n"

    console.log(s)
    code_text.value = s;
    

  }


  function resetCanvas() {

  }


  function AnyDrag(rect) {
    if (rect.dragTL) {
      return 1;
    } else if (rect.dragBL) {
      return 2;
    } else if (rect.dragTR) {
      return 3;
    } else if (rect.dragBR) {
      return 4;
    } else if (rect.dragMove) {
      return 5;
    }
    return 0;
  }

  function ontouchstart(e){
    var touch = e.touches[0];
    e.touches = [];
    mouseDown(touch);
  }

  function ontouchmove(e){
    var touch = e.touches[0];
    e.touches = [];
    mouseMove(touch);
  }


  function ontouchend(e){
    var touch = e.touches[0];
    e.touches = [];
    mouseUp(touch);
  }

  function mouseDown(e) {
    console.log(e)

    mouseX = e.pageX - canvas.offsetLeft - cdiv.offsetLeft-5;
    mouseY = e.pageY - canvas.offsetTop - cdiv.offsetTop-5;
    console.log("x= " , mouseX, " ;y= ", mouseY)
    for (let rect of rects) {

      rect.initMouseX = -1 ;
      rect.initMouseY = -1 ;
      rect.originalStartX = rect.startX;
      rect.originalStartY = rect.startY;

      // if there is, check which corner
      //   (if any) was clicked
      //
      // 4 cases:
      // 1. top left
      if (checkCloseEnough(mouseX, rect.startX) && checkCloseEnough(mouseY, rect.startY)) {
        rect.dragTL = true;
        rect.initMouseX = mouseX ;
        rect.initMouseY = mouseY ;
        break;
      }
      // 2. top right
      else if (checkCloseEnough(mouseX, rect.startX + rect.w) && checkCloseEnough(mouseY, rect.startY)) {
        rect.dragTR = true;
        rect.initMouseX = mouseX ;
        rect.initMouseY = mouseY ;
        break;

      }
      // 3. bottom left
      else if (checkCloseEnough(mouseX, rect.startX) && checkCloseEnough(mouseY, rect.startY + rect.h)) {
        rect.dragBL = true;
        rect.initMouseX = mouseX ;
        rect.initMouseY = mouseY ;
        break;
      }
      // 4. bottom right
      else if (checkCloseEnough(mouseX, rect.startX + rect.w) && checkCloseEnough(mouseY, rect.startY + rect.h)) {
        rect.dragBR = true;
        rect.initMouseX = mouseX ;
        rect.initMouseY = mouseY ;
        break;
      }
      // 5. middle
      else if (checkDragMove(mouseX, mouseY, rect)) {
        rect.dragMove = true;
        rect.initMouseX = mouseX ;
        rect.initMouseY = mouseY ;
        break;
      }
      // (5.) none of them
      else {
        // handle not resizing
      }


    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    draw();

  }

  function checkDragMove(x, y, rect) {
    if (rect === undefined) {
      return false;
    }

    if (x > rect.startX + closeEnough &&
      x < rect.startX + closeEnough + rect.w &&
      y > rect.startY + closeEnough &&
      y < rect.startY + closeEnough + rect.h) {
      return true;
    }

    return false;
  }

  function checkCloseEnough(p1, p2) {
    return Math.abs(p1 - p2) < closeEnough;
  }

  function mouseUp() {
    for (let rect of rects) {
      if (AnyDrag(rect) > 0) {
        rect.dragTL = rect.dragTR = rect.dragBL = rect.dragBR = rect.dragMove = false;
      }
    }
  }

  function mouseMove(e) {
    mouseX = e.pageX - canvas.offsetLeft - cdiv.offsetLeft-5;
    mouseY = e.pageY - canvas.offsetTop - cdiv.offsetTop-5;

    for (let rect of rects) {
      if (AnyDrag(rect) > 0) {
        if (rect.dragTL) {
          rect.w += rect.startX - mouseX;
          rect.h += rect.startY - mouseY;
          rect.startX = mouseX;
          rect.startY = mouseY;
        } else if (rect.dragTR) {
          rect.w = Math.abs(rect.startX - mouseX);
          rect.h += rect.startY - mouseY;
          rect.startY = mouseY;
        } else if (rect.dragBL) {
          rect.w += rect.startX - mouseX;
          rect.h = Math.abs(rect.startY - mouseY);
          rect.startX = mouseX;
        } else if (rect.dragBR) {
          rect.w = Math.abs(rect.startX - mouseX);
          rect.h = Math.abs(rect.startY - mouseY);
        } else if (rect.dragMove) {
          var deltX = rect.initMouseX - mouseX;
          var deltY = rect.initMouseY - mouseY;

          rect.startX = Math.abs(rect.originalStartX - deltX);
          rect.startY = Math.abs(rect.originalStartY - deltY);
        }
      }
    }


    ctx.clearRect(0, 0, canvas.width, canvas.height);
    draw();
  }

  function draw() {
    for (let rect of rects) {
      ctx.strokeStyle = "#222222";
      ctx.lineWidth = 4;
      ctx.strokeRect(rect.startX, rect.startY, rect.w, rect.h);
      ctx.strokeStyle = "#DADA00";
      ctx.lineWidth = 1;
      ctx.strokeRect(rect.startX, rect.startY, rect.w, rect.h);
      drawHandles(rect);
    }
  }

  function drawCircle(x, y, radius) {
    ctx.fillStyle = "#DD0052";
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fill();
  }

  function drawHandles(rect) {
    drawCircle(rect.startX, rect.startY, closeEnough);
    drawCircle(rect.startX + rect.w, rect.startY, closeEnough);
    drawCircle(rect.startX + rect.w, rect.startY + rect.h, closeEnough);
    drawCircle(rect.startX, rect.startY + rect.h, closeEnough);
  }

  

  init();
</script>

	</body>
</html>
